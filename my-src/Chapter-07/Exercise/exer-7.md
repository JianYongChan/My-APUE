# 第7章课后习题

* Linux习题上执行一个输出"hello, world"的程序但不调用`exit`或`return`，则程序的返回代码为13，为什么？

该程序的返回代码为输出的字节数

* 图7-3中的`printf`函数的结果何时才被真正输出？

调用`exit`之后，退出`main`之前

* 是否有方法不使用(a) 参数传递，(b) 全局变量这两种方法，将main函数中的参数argc和argv传递给它所调用的其他函数？

* 在有些Unix系统实现中执行程序时访问不到其数据段的0单元，这是一种有意的安排，为什么？

* 用C语言的`typedef`为终止处理程序定义了一个新的数据类型`Exitfunc`，使用该类型修改`atexit`的原型。

``` C
typedef void (*Exitfunc)(void);
int my_atexit(Exitfunc *func);
```

* 

* 如果用`calloc`分配一个long型的数组，数组的初始值是否为0？如果用`calloc`分配一个指针数组，数组的初始值是否为空指针？

是 是

* 在7.6节结尾处`size`命令的输出结果中，为什么没有给出堆和栈的大小？

这个不清楚
* 为什么7.7节中两个文件的大小(879443和8378))不等于它们各自文本和数据的大小的和？

可执行文件中还包含一些用于调试的符号表

* 为什么7.7节中对于一个简单的程序，使用共享库之后其可执行文件的大小变换如此巨大？

* 在7.10节中我们已经说明为什么不能将一个指针返回给一个自动变量，下面的程序是否正确？

``` C
int f1(int val) {
    int num = 0;
    int *ptr = &num;
    if (val == 0) {
        int val;
        val = 5;
        ptr = &val;
    }

    return (*ptr + 1);
}
```

不正确。如果传入`f1`的`val == 0`，那么在`if`语句块中创建的`val`屏蔽了外部的val，是一个局部变量，在`if`语句块结束后就被销毁，所以ptr指向的内存无效。
